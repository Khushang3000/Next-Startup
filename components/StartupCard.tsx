import React from 'react'
import { formatDate } from '@/lib/utils'
import { EyeIcon } from 'lucide-react'
import Link from 'next/link'
import Image from 'next/image'
import { Button } from './ui/button'
import { Author, Startup } from '@/sanity/types'

//Omit- Construct a type with the properties of T except for those in type K.
export type StartupCardType = Omit<Startup,"author"> & {author? : Author}//author will be optional, and it will be of type Author.
//we want to create a type, which takes all properties of Startup except the "author" property, and author is optional and is of type Author.
//Startup and Author types were generated by sanity's own typegen in the types.ts file.
//also use this type in home page by importing.
//now you'll get the typescript errors like property _id doesn't exist on author, so for that, 
//instead of destructuring these properties automatically, we'll just take author
//and wherever we wanna use those properties on author, we can just do author._id like this
//but wait, since author is optional, we gotta access those properties like author?._id
//now next thing we'll do is dive a bit into how nextjs caches our data and how we can further customize it depending on the type of our application.
//we'll do it for the kind of application which has to show the new posts immediately


const StartupCard = ({post}:{post: StartupCardType}) => {

    const {_createdAt, views,description, author, title, category, image, _id }= post;
    //here we're destructuring post, now if you see author, we're destructuring it as well!!! 
    //there's one thing tho, if we directly destructured it like, author:{_id, name}, then there are two conflicting _ids so that's why we renamed author's _id to authorId

    //we'll add this StartupTypeCard later once we immplement sanity, as one of it's great features is automatic type checking for documents in our collection
  return (
    <li className="startup-card group hover:bg-pink-200">
        {/* Think of it as:

group → marks a parent element as a "group".

group-* variants → let child elements respond to the parent’s state (like hover, focus, etc.).

Example: Button with icon that changes color on hover
<button className="group flex items-center space-x-2 p-3 bg-gray-200 rounded-lg hover:bg-gray-300">
  <span className="text-gray-700 group-hover:text-blue-600">Click Me</span>
  <svg
    className="w-5 h-5 text-gray-700 group-hover:text-blue-600"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"
  >
    <path d="M5 12h14" />
  </svg>
</button>


The button has the group class.

The <span> and <svg> inside use group-hover:* to change their styles when the parent is hovered.

Without group

You’d only be able to apply hover: styles directly on the element itself.
With group, you can cascade hover/focus/active states from parent → children.
 */}
        <div className='flex-between'>
            <p className="startup_card_date">
                {formatDate(_createdAt)}
                {/* rn we're just using the value of createdAt as a simple static string but what if we could use the js new Date() object, 
                we wouldn't be able to render it here like normal, so we somehow need to format the date(convert it into string), and for that we'll create a function in the lib/utils.ts */}
                {/* make sure you change the createdAt to new Date() object in the page.tsx */}
            </p>
            <div className="flex gap-1.5">
                <EyeIcon className='size-6 text-primary hover:text-pink-700' />
                <span className='text-16-medium'>{views}</span>
            </div>
        </div>
        <div className="flex-between mt-5 gap-5">
          <div className="flex-1">
            <Link href={`/user/${author?._id}`}>
            {/* line-clamp-1 ensures that user stays on one line */}
                  <p className="text-16-medium line-clamp-1">
                    {author?.name}
                  </p>
            </Link>
            <Link href={`/startup/${_id}`}>
                  <p className="text-26-semibold line-clamp-1">{title}</p>
            </Link>
          </div>
          <Link href={`/user/${author?._id}`}>
          {/* nextjs won't allow us to render the image as it doesn't know if we trust this placehold.co link, so we gotta set it to allow in nextjsconfig.ts */}
                  <Image src="https://placehold.co/48x48" alt='Placeholder' width={48} height={48} className='rounded-full' />
          </Link>
        </div>
        {/* let's create another link for details */}
        <Link href={`/startup/${_id}`}>
                  <p className="startup-card_desc">
                    {description}
                  </p>
                  {/* right here below this p tag we could add an image, but in this case we don't have to. we can also use a regular html image */}
                  <img src={image} alt="placeholder" className='startup-card_img' />
        </Link>

        {/* footer of the card */}
        <div className="flex-between gap-3 mt-5">
          {/* category is optional as well. */}
          <Link href={`/?query=${category?.toLowerCase()}`}>
                  <p className="text-16-medium">{category}</p>
          </Link>
          <Button className="startup-card_btn" asChild>
            {/* asChild, 
            asChild makes the Next.js <Link> act as the button itself.

            All styles (startup-card_btn, hover states, etc.) are applied directly to the <Link>.

            This avoids the invalid <button><a></a></button> nesting which causes accessibility errors in plain html.
            
            Good job, now we just have one problem, we're using fake data, that's why in next commit we'll use sanity.
            it'll be sanity setup*/}
            <Link href={`/startup/${_id}`}>Details</Link>
          </Button>
        </div>
    </li>
  )
}

export default StartupCard